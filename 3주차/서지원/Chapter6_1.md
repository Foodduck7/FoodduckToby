# Chapter6 AOP

> ### 📌 책에 나와 있는 트랜잭션 경계 설정 분리 과정은 생략했다. 
>
> **추후 보고 싶다면 `401 ~ 423 page` 참고**

## 단위 테스트와 통합 테스트 

💭 단위 테스트와 통합 테스트 중 어떤 방법을 어떤 상황에 사용해야 할까?

- **항상 단위 테스트를 먼저 고려**한다. 
- 단위 테스트로 만들기 어려운 DAO의 경우에는 DB까지 연동하는 테스트로 만드는 것이 효과적이다. 
- `외부 리소스`를 사용해야만 가능한 테스트는 **통합 테스트로 만든다.** 
- DAO 테스트는 외부 리소스를 사용하기 때문에 통합테스트로 분류된다. 
- 여러 개의 단위가 의존관계를 가지고 동작할 때는 통합

<br>

### 목 프레임워크 (Mockito) 

**목 오브젝트 생성 (given)**
```java
UserDao mockUserDao = mock(UserDao.class); // 아직 아무 기능이 없는 목 객체 생성
```

<br>

**정보 반환하기(when)** 

```java
when(mockUserDao.getAll()).thenReturn(this.users);// getAll()이 호출될 때 this.users 리스트 반환하도록 설정
```

<br>

**검증하기(then)** 

```java
verify(mockUserDao, times(2)).update(any(User.class)); // mockUserDao.update()가 어떤 User 객체를 대상으로든 2번 호출되었는지 검증
```


<br>

## 다이나믹 프록시와 팩토리 빈 

> ### 📌 공부하고 다시 읽어봐야 할 것 같다. (429 ~ 449 page) 

### 프록시와 프록시 패턴, 데코레이터 패턴

**자신이 클라이언트가 사용하려고 하는 `실제 대상인 것처럼`** 위장해서 클라이언트의 **요청을 받아주는 것**을 <span style="color:orange;">**프록시(Proxy)**</span>라고 한다. 

> 💡 프록시를 통해 최종적으로 요청을 위임받아 처리하는 **실제 오브젝트**를 `타킷(target)` 또는 `실체(real subject)`라고 한다.

<br>

`프록시`는 **타깃과 같은 인터페이스를 구현**했고 **프록시가 타킷을 제어할 수 있는 위치에 있다.** 

프록시는 **사용목적에 따라 두가지로 분류**할 수 있다. 

- 클라이언트가 타깃에 접근하는 방법을 제어
- 타깃에 부가적인 기능을 부여


<br>

### 데코레이터 패턴 

**타깃에 부가적인 기능**을 `런타임 시` 다이내믹하게 <ins>**부여해주기 위해 프록시를 사용하는 패턴**</ins>을 의미한다. 

> 🔎 코드상에서는 **어떤 방법**과 **순서**로 <ins>**프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다.**</ins> 

데코레이터 패턴의 대표적 예시 ➡︎ 자바 IO 패키지의 InputStream과 OutStream
 
<br>

**[간단한 사용법]** 

- 인터페이스 만들기

- 해당 인터페이스를 구현한 기본 클래스 만들기

- 기능을 확장하는 데코레이터 클래스를 추가

### 🚀 데코레이터 패턴은 <ins>타깃의 코드에 손대지 않고</ins>, <ins>클라이언트가 호출하는 방법도 변경하지 않은 채</ins>로 <span style="color:orange;">새로운 기능을 추가할 때</span> 유용하다. 

<br>

### 프록시 패턴 

`일반적으로 사용하는 프록시:` **클라이언트**와 **사용 대상** 사이에 <span style="color:orange;">**대리 역할을 맡은 오브젝트를 두는 방법을 총칭**</span>한다. 

`디자인 패턴에서의 프록시:` <span style="color:orange;">**타깃에 대한 접근 방법을 제어하려는 목적**</span>을 가진 경우

일반적으로 **타깃 오브젝트를 생성하기 복잡하거나 당장 필요하지 않는 경우**에는 꼭 <ins>**필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.**</ins>

➡︎ 다만 `타깃 오브젝트에 대한 레퍼런스가 미리 필요하다면` 프록시 패턴을 적용한다. 

<br>

🔎 **클라이언트에게** 실제 타깃이 아닌 **프록시를 넘겨주고** 메소드를 통해 `타깃 사용을 시도할 때` **프록시가 타깃 오브젝트를 생성하여 요청을 넘겨주는 방식**으로 작동한다. 

<br>

### 프록시의 구성과 문제점 

앞서 살펴봤듯 프록시는 2가지의 기능으로 구성된다. 
- 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임
- 지정된 요청에 대해 부가 기능 수행 

<br>

**🚨[문제점]🚨**

- 타깃이 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다. 
- 인터페이스의 메소드가 많아지고 다양해진다면 개발자가 해야할 작업이 많아진다.** 
- 부가기능 <span style="color:#F05750;">**코드가 중복될 가능성**</span>이 있다. (트랜잭션 경계 설정 등)

➡︎ 위의 문제들을 해결하기 위한 방법이 `JDK의 다이내믹 프록시`이다. 

<br>

### 리플렉션

자바의 코드 자체를 추상화해서 접근하도록 만든 것을 의미한다. 

> 💡 **구체적인 클래스 타입을 알지 못해도 그 클래스의 메서드, 타입, 변수들에 접근할 수 있도록 해주는 것** 


```java
int length = lengthMethod.invoke(변수) // invoke를 length() 메소드를 호출한다. 
```


![Image](https://github.com/user-attachments/assets/0ce8fa73-de1b-440e-9e1b-ea5146b70aae)


<br>

> `newInstance(): ` 클래스의 파라미터가 없는 생성자를 호출하고, 그 결과 생성되는 오브젝트를 돌려주는 리플랙션 API이다.


<br>

### 팩토리 빈 

스프링은 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈을 말한다. 

**[가장 간단한 구현 방법]**

FactoryBean 인터페이스 구현 

```java
public interface FactoryBean<T> {
    T getObject() throws Exception // 빈 오브젝트 생성 및 반환
    Class<? extends T> getObjectType(); // 생성되는 오브젝트 타입
    boolean isSingleton(); // getObject()가 반환하는 오브젝트가 싱글톤인지 알려준다. 
}
```

