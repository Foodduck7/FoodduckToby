## 5.3  서비스 추상화의 단일 책임 원칙

비즈니스 로직을 담은 코드/데이터 접근 로직 코드 분리해야 한다<br>
비즈니스 로직을 담은 코드도 책임과 역할에 따라 분리해야한다

DAO의 결합도를 낮춰야 함 -> 인터페이스와 DI(의존성 주입을) 활용하자

DAO를 사용하는 비즈니스 로직은 트랜잭션이 필요하다<br>
트랜잭션은 단위 작업을 보장해준다

#### 트랜잭션 경계설정 : 트랜잭션의 시작과 종료 지정
+ 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어난다

트랜잭션 정보를 담은 객체를 매개변수로 DAO 로 전달하는 방법을 비효율적이다<br>
스프링의 트랜잭션 동기화 기법을 활용하자

트랜잭션 API 종류와 방법은 다양하다<br>
환경과 서버에 따라 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경하자

트랜잭션 변경에 따라 비즈니스 로직 코드가 변경되어서는 안된다<br>
이는 단일 책임 원칙에 위배된다 -> 강한 결합이 발생할 수 있다

스프링의 트랙잭션 서비스 추상화를 이용하면 트랜잭션과 비즈니스 코드의 결합을 막을 수 있다

서비스 추상화는 테스트하기 어려운 JavaMail 에도 적용할 수 있다<br>
테스트를 편리하게 해준다

테스트 대역: 테스트 대상이 사용하는 오브젝트 대체<br>
테스트 대역은 테스트 대상 오브젝트의 테스트 외의 동작을 원활하게한다<br>
테스트에 대한 간접적인 정보를 제공하기도 한다

목(Mock) 객체: 테스트 대역 중 테스트 대상의 정보를 검증할 수 있도록 설계된 것

## 6장 AOP

트랜잭션 경계설정 코드의 분리와 DI를 통한 연결의 장점<br>
1. 서비스 구현체의 코드를 작성할 때 트랜잭션에 대한 신경을 쓰지 않아도 된다
2. 비즈니스 로직에 대한 테스트를 보다 쉽게 만들 수 있다

좋은 테스트 방법: 작은 단위로 쪼개서 태스트하는 것<br>
테스트의 의도나 내용이 분명해진다<br>
테스트 실패에 대한 원인을 쉽게 찾을 수 있다

고립된 테스트: 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없다<br>
테스트 수행 성능도 크게 향상된다

단위 테스트:<br>
테스트 클래스를 목 객체 등의 테스트 대역을 이용해 의존 객체나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것

통합 테스트:<br>
두 개 이상의 성격이나 계층이 다른 객체가 연동하도록 만들어 테스트하는 것<br>
외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트<br>
스프링의 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서 생성되고 DI된 객체 테스트

단위 테스트의 단위<br>
+ 사용자 관리 기능 전체
+ 하나의 클래스
+ 하나의메소드

#### 개발자의 테스트
1. 단위 테스트를 먼저 고려한다


2. 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단한다<br>
   필요에 따라 스텁/목 객체 등의 테스트 대역을 이용한다<br>
   단위 테스트를 할 때 빠르고 효과적으로 테스트를 작성할 수 있는 이유:<br>
   + 테스트 작성에 간단함
   + 실행 속도 빠름
   + 테스트 대상 외 코드나 환경으로부터 테스트 결과에 영향을 받지 않음


3. 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다


4. 단위 테스트로 만들기가 어려운 코드: DAO<br>
   로직이라기 보다는 DB를 통해 로직을 수행하는 인터페이스 역할<br>
   DB에 테스트 데이터를 준비하고 직접 확인을 하는 등의 부가적 작업 필요


5. DAO 테스트는 통합 테스트
   코드에서 보면 하나의 기능 단위를 테스트 하는 것<br>
   테스트한 DAO는 스텁이나 목 오브젝트로 대체해서 테스트할 수 있다


6. 단위 테스트를 충분히 거친 통합 테스트은 부담이 줄어든다

7. 단위 테스트를 만들기가 복잡한 코드는 통합 테스트를 처음부터 고려한다<br>
   그 중 가능한 한 많은 부분을 미리 단위 테스트로 검증한다

8. 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트이다<br>
   사용하는 경우: 스프링 설정, 스프링을 이용해 추상적인 레벨에서 테스트해야하는 경우가 있음

테스트하기 편하게 만들어진 코드는 깔끔3하고 좋은 코드가 될 가능성이 높다

목 오브젝트 지원 프로그램

Mockito 프레임워크<br>
목 클래스를 준비할 필요가 없다

1. 인터페이스를 이용해 목 오브젝트를 만든다
2. 목 오브젝트가 리턴할 값/예외를 지정한다
3. 테스트 대상 오브젝트에 의존성을 주입해서 목 오브젝트가 테스트 중에 사용되도록 한다
4. 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출되었는지 어떤 값을 가지고 몇번 호출되었는지 검증한다


프록시(proxy)/대리자
: 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것<br>
타깃(target)/실체(real subject)<br>
: 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트

프록시의 목적
1. 클라이언트가 타깃에 접근하는 방법 제어
2. 타깃에 부가적인 기능을 부여

데코레이터 패턴
: 타깃에 부가적인 기능을 런타임 시 동적으로 부여해주기 위해 프록시를 사용하는 패턴<br>
동적으로 기능 부가: 컴파일 시점(실행되기 전)에는 코드상에 프록시와 타깃이 어떤 방법과 순서로 연결되어 사용되는지 정해져있지 않다<br>
실제 내용물은 동일하지만 부가적인 효과를 부여해준다<br>
같은 인터페이스를 구현한 타깃과 여러 개의 프록시를 사용할 수 있다

대표적인 예시<br>
+ InputStream/OutputStream

#### 프록시 패턴
+ 프록시 패턴의 프록시: 타깃에 대한 접근 방법을 제어하려는 목적의 프록시<br>
+ 클라이언트가 타깃에 접근하는 방식을 변경한다<br>
+ 타깃 객체에 대한 레퍼런스가 미리 필요할 수 있다<br>
+ 실제 타깃 객체 대신에 프록시를 넘겨준다<br>
+ 프록시의 메소드를 통해 타깃을 사용하려고 하면 프록시가 타깃 객체를 생성하고 요청을 위임해준다<br>
+ 프록시를 통해서 객체 생성을 최대한 늦출 수 있다

원격 객체를 사용할 때 or 원격 기술을 이용해 다른 서버에 존재하는 객체를 사용해야할 때<br>
프록시를 로컬에 존재하는 객체처럼 사용한다<br>
클라이언트의 요청을 받으면 네트워크를 통해 원격의 객체를 실행하고 결과를 받아서 클라이언트에 돌려준다

타깃에 대한 접근 권한을 제어하기 위해 사용<br>
수정 가능한 오브젝트가 있을 떄 특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제하고 싶을 때

프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다

프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방벙르 제어할 수 있는 유용한 방법

프록시의 두 가지 기능
1. 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다
2. 지정된 요청에 대해서는 부가기능을 수행한다

프록시를 만들기 번거로운 이유
1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다<br>
   ->  JDK Reflection 으로 해결
2. 부가기능 코드가 중복될 가능성이 많다<br>
   -> 중복되는 코드 분리로 해결(refactor)

Reflection
: 자바의 코드 자체를 추상화해서 접근하도록 만든 것

Proxy의 newProxyInstance()<br>
매개변수:(클래스 로더, 인터패이스(동적 프록시가 구현할) 배열, InvocationHandler 구현체(invoke 메소드))<br>
리턴:Object -> 캐스팅해서 사용하자<br>

동적 프록시 객체: 일반적인 스프링 빈으로 등록할 수 없다<br>
스프링은 지정된 클래스 이름으로 리플렉션을 이용해 객체를 만든다<br>
다이내믹 프록시는 Proxy 클래스의 static newProxyInstance() 메소드를 통해서 만든다<br>

#### 팩토리 빈
스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 빈

스프링의 FactoryBean 인터페이스 구현

+ 스프링은 private 생성자의 클래스도 빈으로 등록하면 리플렉션으로 객체를 생성한다

+ 스프링은 getBean() 메소드 내부에 '&' 을 빈 앞에 붙이면 팩토리 빈 자체를 리턴한다<br>
ex) Object factory = context.getBean("&message");

프록시 팩토리 빈의 재사용
코드의 수정 없이도 다양한 클래스에 적용할 수 있다

데코레이터 패턴 문제점
1. 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야 한다<br>
   -> 핸들러 구현과 팩토리 빈을 이용한 DI 로 해결
2. 부가적인 기능이 여러 메소드에 반복적으로 나타남 -> 코드 중복 문제<br>
   -> 핸들러 메소드로 수많은 메소드에 부가기능 부여<br>

+ 동적 프록시로 위 두 가지의 문제점을 해결할 수 있다


### 궁금하고 알아보고 싶은 것
+ proxy 클래스
+ Method 클래스
+ atttribute 개념