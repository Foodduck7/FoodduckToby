오브젝트의 동일성과 동등성

동일성(identity): 두 개의 오브젝트가 완전히 동일한 객체<br>
동등성(equality): 두 개의 오브젝트가 동일한 정보를 담고 있음<br>

두개의 객체가 동일함 -> 하나의 오브젝트만 존재하며 두개의 참조 변수를 갖는 것<br>
== 연산자 비교<br>
두개의 객체가 동등함 -> 두 개의 다른 오브젝트가 메모리에 존재<br>
Object.equals() 메소드<br>
두개의 객체가 동등하지만 동일하지 않을 수 있다<br>

Object 클래스의 equals() 메소드는 동등성을 비교한다<br>

어플리케이션 컨텍스트<br>
IOC 컨테이너<br>
싱글톤 레지스트리(singleton registry)<br>

싱클톤 패턴(Singleton Pattern)<br>
어떤 클래스를 어플리케이션 내에서 인스턴스를 하나만 존재하도록 강제한다<br>
생성된 인스턴스는 어플리케이션 내에서 전역적으로 접근이 가능하다/static<br>

싱글톤 구현 방법<br>
생성자 private 으로 만들기<br>
-> 추가 생성자 없으면 상속이 불가능하다/다형성 구현 어렵다<br>
싱글톤 오브젝트를 저장할 수 있는 자기 클래스 타입의 static 필드 정의<br>
getInstance() 메서드를 만든다<br>
이 메소드는 최초 호출되는 시점에서 한번만 오브젝트가 만들어진다<br>
객체가 생성되면 static 필드에 저장된다<br>
static 필드를 미리 초기화하기도 한다<br>
오브젝트가 만들어진 후에는 getInstance() 메소드로 static 필드값을 사용한다<br>

테스트용 오브젝트로 대체하기 힘들다<br>

싱글톤 레지스트리(singleton registry)<br>
: 자바의 기본 싱글톤의 단점을 보완한 스프링 싱글톤 관리 컨테이너<br>
싱글톤 생성, 관리, 공급<br>
싱글톤 형식(스태틱 메소드, private 생성자)가 아니어도 싱글톤으로 활용하게 한다<br>
객체 지향적인 설계 방식과 디자인 패턴을 제약 없이 사용가능하다<br>

멀티스레드 환경에서 여러 스레드가 싱글톤에 동시 접근 사용 가능/race condition<br>
무상태방식으로 만들어야한다<br>
무상태(stateless): 상태정보를 내부에 갖지 있지 않은 방식<br>
데이터 무결성 지켜야함<br>

빈의 스코프(scope)<br>
: 스프링 객체(빈)이 생성되고, 존재하고, 적용되는 범위<br>
스프링 빈의 기본 스코프는 싱글톤이다<br>
그 외의 스코프를 가지기도 한다<br>
ex) 프로토타입(prototype): 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다<br>
요청 스코프: HTTP 요청이 생길 때마다 생성<br>
세션 스코프<br>

의존 관계 주입(Dependency Injection)<br>
객체는 다른 객체에 주입할 수 없다<br>
레퍼런스만 전달된다<br>
DI: 레퍼런스 외부로부터 주입 -> 다른 객체들과 동적으로 의존관계 형성<br>

의존관계<br>

의존성: 한 클래스(B)의 변화가 다른 클래스(A)로 영향을 미칠 때<br>
방향성을 띈다/의존한다: A가 B에 의존한다<br>

의존 오브젝트(dependent object):<br>
런타임 시점에서 의존관계를 맺는 실제 사용 대상<br>

의존 관계 주입의 3가지 조건<br>
클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다/인터페이스에만 의존<br>
런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다<br>
의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다<br>

의존관계 검색(Dependency Lookup)<br>
의존관계를 맺는 방법: 스스로 검색/외부로부터 주입이 아님<br>
능동적으로 필요로 하는 의존 객체를 찾는다<br>
의존관계를 맺을 객체 결정과 오브젝트 생성작업은 외부 컨테이너에 맡김<br>
객체를 가져올 때는 스스로 컨테이너에게 요청한다/메소드나 생성자 통한 방법 사용하지 않는다<br>

의존관계 검색시 검색하는 객체는 bean일 필요가 없다<br>
의존관계 주입시에는 bean으로 등록해야한다<br>

주입받는 메소드 매개변수가 이미 특정 클래스 타입으로 고정되어 있다면 의존 관계 주입이 일언ㄹ 수 없다<br>
동적으로 구현 클래스를 결정해서 제공받아야한다 -> 인터페이스 타입의 매개변수로 이뤄줘야한다<br>

런타임 클래스에 대한 의존관계가 코드에 드러나지 않는다<br>
인터페이스를 통해 결합도가 낮은 코드를 만듦<br>
-> 변화가 생겨도 자신은 영향 받지 않고 변경을 통해 확장에 자유롭다<br>

수정자 메서드(setter)를 이용한 의존관계 주입<br>
XML을 사용하는 경우에 자바빈 규약을 따르는 수정자 메소드가 사용하기 편함<br>
일반 메소드를 이용한 주입: 여러개의 파라미터를 받을 수 있다<br>

어떻게 객체를 설계할 것인가<br>
어떻게 객체를 만들 것인가<br>
어떻게 객체 간의 관계를 형성할 것인가<br>
어떻게 객체를 분리하고, 개선하고, 의존관계를 가질지 결정할 것인가<br>
