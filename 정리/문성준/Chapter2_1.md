# 테스트와 단위 테스트의 중요성

## 1. 테스트란 무엇인가?

테스트는 개발자가 작성한 코드가 **의도한 대로 동작하는지 확인하는 과정**이다.

테스트를 수행함으로써 **설계의 결함을 발견하고**, 이를 수정할 수 있으며, 최종적으로 테스트가 성공했을 때 **코드의 안정성을 보장할 수 있다.**

하지만, 개발자가 직접 테스트를 만들 때 흔히 하는 실수가 있다.

- **성공하는 테스트만 만드는 것**: 실패할 가능성이 있는 케이스는 무의식적으로 피하는 경우가 많음.
- **예외 상황을 고려하지 않는 것**: 특수한 입력 값이나 예외 발생 가능성이 있는 경우를 테스트하지 않음.

이러한 실수를 방지하려면 체계적으로 테스트를 작성해야 한다.

---

## 2. 테스트의 종류와 단위 테스트(Unit Test)

### **2.1 웹을 통한 테스트의 문제점**

많은 개발자들은 웹 애플리케이션을 테스트할 때 **프론트엔드 UI에서 버튼을 눌러서 확인하는 방식**을 사용한다. 하지만 이런 방식에는 다음과 같은 문제가 있다.

- **모든 레이어가 구현된 후에야 테스트가 가능하다.**
- **에러 발생 시 원인을 찾기 어렵다.**
- **자동화가 불가능하며 반복적인 작업이 많다.**

따라서, 보다 작은 단위에서 테스트하는 단위 테스트(Unit Test)가 필요하다.

### **2.2 단위 테스트란?**

단위 테스트는 **애플리케이션의 특정 기능이나 로직을 작은 단위로 쪼개어 테스트하는 것**을 의미한다.

📌 단위 테스트의 핵심

- **작은 단위의 테스트**: 한 번에 하나의 기능만 테스트
- **독립적인 테스트**: 다른 테스트와 영향을 주고받지 않음
- **반복 가능한 테스트**: 환경이 달라도 동일한 결과를 보장

```
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

@Test
void testAddition() {
    Calculator calculator = new Calculator();
    assertThat(calculator.add(2, 3), is(5));
}
```

위와 같이 특정 기능(덧셈)을 검증하는 작은 단위의 테스트를 작성한다.

---

## 3. 자동화된 테스트의 필요성

### **3.1 main() 메서드를 이용한 테스트의 문제점**

```
public static void main(String[] args) {
    Calculator calculator = new Calculator();
    int result = calculator.add(2, 3);
    if (result == 5) {
        System.out.println("테스트 성공");
    } else {
        System.out.println("테스트 실패");
    }
}
```

- **개발자가 직접 결과를 확인해야 한다.**
- **여러 개의 테스트를 실행하는 것이 번거롭다.**
- **자동화가 불가능하다.**

이를 해결하기 위해 **JUnit 같은 테스트 프레임워크**를 사용해야 한다.

### **3.2 JUnit을 이용한 자동화된 테스트**

JUnit은 Java에서 단위 테스트를 쉽게 수행할 수 있도록 도와주는 테스팅 프레임워크이다.

```
import static org.junit.Assert.*;
import org.junit.Test;

public class CalculatorTest {
    @Test
    public void testAddition() {
        Calculator calculator = new Calculator();
        assertEquals(5, calculator.add(2, 3));
    }
}
```

**JUnit을 사용하면 결과를 자동으로 검증할 수 있으며, IDE에서 간편하게 실행 가능하다.**

---

## 4. 테스트 결과의 일관성과 독립성

### **4.1 단위 테스트가 일관적인 결과를 가져야 하는 이유**

테스트는 **항상 동일한 환경에서 동일한 결과를 반환**해야 한다. 하지만 아래와 같은 경우 문제가 될 수 있다.

- **테스트 실행 순서에 따라 결과가 달라지는 경우**
- **DB의 상태에 따라 결과가 달라지는 경우**
- **외부 API 호출에 따라 결과가 변하는 경우**

### **이러한 문제를 방지하려면?**

- 테스트 전후에 **DB 초기화** (`deleteAll()`)
- **Mock 객체** 사용하여 외부 API 호출 차단
- 특정 순서 보장이 필요한 경우 `@FixMethodOrder` 사용

### **4.2 예외 처리 테스트**

JUnit에서는 특정 예외가 발생하는지 확인할 수도 있다.

```
@Test(expected = IllegalArgumentException.class)
public void testException() {
    throw new IllegalArgumentException();
}
```

위 코드는 `IllegalArgumentException` 예외가 발생해야 테스트가 성공한다.

---

## 5. 테스트 주도 개발 (TDD)

### **5.1 TDD란?**

TDD(Test Driven Development)는 **테스트를 먼저 작성하고, 이를 통과하는 코드를 작성하는 방식**이다.

### 📌 **TDD의 과정**

1.  **테스트를 먼저 작성한다.**

1.  **테스트를 실행하여 실패하는지 확인한다.**
2. **테스트를 통과하도록 최소한의 코드를 작성한다.**
3. **코드를 리팩토링하여 개선한다.**

### **5.2 TDD 예제**

```
@Test
public void testMultiplication() {
    Calculator calculator = new Calculator();
    assertEquals(6, calculator.multiply(2, 3));
}
```

- **이 상태에서 코드를 실행하면 실패한다.**
- **그러면 `multiply()` 메서드를 추가하고, 코드를 작성한다.**

```
public int multiply(int a, int b) {
    return a * b;
}
```

✔ **이제 테스트를 실행하면 성공한다.**

**TDD를 활용하면, 코드의 신뢰성을 높이고, 불필요한 코드를 방지할 수 있다.**

---

## 6. 테스트 코드 개선

테스트 코드도 유지보수가 필요하다. 이를 위해 **중복 제거와 코드 정리**를 수행해야 한다.

### **6.1 @Before을 이용한 테스트 초기화**

```
public class CalculatorTest {
    private Calculator calculator;

    @Before
    public void setUp() {
        calculator = new Calculator();
    }

    @Test
    public void testAddition() {
        assertEquals(5, calculator.add(2, 3));
    }
}
```

- **테스트 실행 전 `@Before` 메서드가 먼저 실행되어 초기화됨.**
- **여러 테스트에서 같은 객체를 매번 생성하는 중복을 줄일 수 있음.**

---

## 7. 결론

테스트는 단순히 코드 검증을 위한 것이 아니라, 코드의 **안정성을 높이고 개발 속도를 향상시키는 중요한 과정**이다.

- **자동화된 테스트를 통해 유지보수성을 높일 수 있다.**
- **테스트 주도 개발(TDD)을 활용하면 코드 품질이 향상된다.**
- **JUnit을 활용하면 단위 테스트를 더욱 효율적으로 수행할 수 있다.**

---

# 실무에서 생각해본다면?

## **1. 단위 테스트와 통합 테스트**

### **⁉️단위 테스트 (Unit Test)**

❓ 단위 테스트에서 Mocking을 어떻게 활용할 수 있을까?

- Mockito, @MockBean, @SpyBean의 차이점과 사용 사례는?
- 실제 데이터베이스 없이 Repository 계층을 단위 테스트하려면?

**❓단위 테스트와 통합 테스트의 경계를 어떻게 정해야 하는가?**

- "이건 단위 테스트로 충분하다" vs "이건 통합 테스트까지 해야 한다"의 기준은?
- Service Layer는 단위 테스트로 충분할까, 아니면 통합 테스트까지 포함해야 할까?

❓ **서비스 레이어의 단위 테스트를 작성할 때, DB 연동이 필요한 경우 어떻게 할까?**

- `H2` 같은 인메모리 DB를 활용하는 방법 vs Mocking을 활용하는 방법의 차이는?

---

## **2. 테스트 코드의 신뢰성과 유지보수**

### ⁉️ **테스트 결과의 일관성 유지**

❓ 테스트 실행 순서가 바뀌면 테스트가 실패하는 문제가 발생할 수 있다.

- Spring Boot 테스트에서 `@DirtiesContext`를 사용할 경우의 장단점은?
- `@TestMethodOrder`를 활용해서 테스트 실행 순서를 명확하게 지정하는 것이 좋은가?

❓ 테스트 코드가 시간이 지남에 따라 점점 복잡해지고 실행 시간이 길어질 때 어떻게 유지보수할까?

- 통합 테스트를 무분별하게 늘리면 빌드 시간이 길어지는 문제가 생기는데, 이를 어떻게 해결할 수 있을까?
- API 변경이 발생하면 관련된 테스트를 어떻게 빠르게 찾고 수정할 수 있을까?

❓ **TDD를 실무에서 적용하는 것이 항상 가능할까?**

- 예: 기존 레거시 코드베이스에서 TDD 방식으로 리팩토링하려면 어떤 접근이 필요할까?

---

## **3. Spring Boot와 테스트 자동화**

### ⁉️ **Spring 환경에서 테스트를 더 효과적으로 관리하는 방법**

❓ Spring Boot에서 **ApplicationContext를 공유하는 방법과 성능 최적화 방법**은?

- `@SpringBootTest`를 사용하면 ApplicationContext를 매번 새로 생성하는데, 이를 최적화하려면?
- `@TestConfiguration`을 활용하여 테스트 전용 빈을 주입하는 방법은?

❓ `@Transactional`을 활용한 테스트는 왜 실행 후 자동 롤백되는가?

- `@Transactional`을 이용한 테스트가 실패하면 어떤 식으로 디버깅할 수 있을까?

❓ Spring Security가 적용된 API를 테스트하려면 어떻게 해야 할까?

- 인증이 필요한 컨트롤러를 MockMvc로 테스트하려면?
- Security Filter를 우회하는 테스트 설정을 어떻게 할까?

---

## **4. 데이터베이스와 테스트**

### ⁉️ **DB를 활용한 테스트 최적화**

❓ `@DataJpaTest`를 사용할 때, 실제 DB 대신 **H2 메모리 DB를 사용하는 것이 좋은가?**

- H2, PostgreSQL, MySQL을 함께 사용하는 테스트 환경을 설정하려면 어떻게 해야 할까?
- Flyway나 Liquibase를 이용하여 DB 마이그레이션을 적용한 상태에서 테스트하려면?

❓ 테스트 환경에서 **테스트 데이터를 관리하는 방법은?**

- `@Sql`을 활용해서 미리 데이터 삽입 vs `TestContainer`를 이용한 방법 중 어떤 것이 더 좋을까?
- 테스트 실행 후 데이터 정리를 자동화하려면?

❓ 실무에서 테스트 데이터가 점점 많아질 때, 어떻게 관리할 수 있을까?

- 더미 데이터를 자동으로 생성하는 `@Faker` 같은 라이브러리를 활용하는 것이 좋은가?
- `given-when-then` 패턴을 유지하면서 가독성을 확보하려면?

---

## **5. 테스트 전략과 운영 환경 적용**

### ⁉️ **테스트 전략 수립**

❓"테스트 커버리지를 80% 이상으로 유지하라"라는 기준이 실무에서 유효한가?

- 단순히 커버리지가 높다고 해서 좋은 테스트 코드라고 할 수 있는가?
- 코드 커버리지를 높이는 것보다 더 중요한 요소는 무엇인가?

❓ **운영 환경과 유사한 환경에서 테스트하려면?**

- 로컬에서는 잘 되지만, 운영 환경에서는 실패하는 테스트가 종종 발생한다면?
- `TestContainers`를 활용하여 실제 DB 환경에서 테스트할 필요가 있는 경우는?

❓ **API 테스트 자동화 전략**

- REST API의 요청과 응답을 자동화하는 가장 좋은 방법은?
- `RestAssured` vs `MockMvc`의 차이점과 선택 기준은?
- 대규모 프로젝트에서 API 테스트를 지속적으로 유지보수하려면?

---

## **6. 마이크로서비스와 테스트**

### ⁉️ **마이크로서비스 아키텍처에서 테스트 전략**

❓ 마이크로서비스 환경에서 테스트의 어려움은?

- 하나의 서비스가 변경되면, 다른 서비스와의 연동 테스트는 어떻게 해야 할까?
- E2E(End-to-End) 테스트를 효율적으로 수행하는 방법은?

❓ **Kafka, RabbitMQ 같은 메시지 브로커를 활용한 테스트**

- 비동기 이벤트 기반 시스템에서 단위 테스트를 작성하는 방법은?
- `EmbeddedKafka`를 활용한 테스트 사례는?

❓ **컨테이너 기반 테스트 (Docker, Kubernetes)**

- CI/CD 파이프라인에서 테스트 실행 속도를 높이려면?
- 운영 환경과 동일한 설정을 유지하면서 테스트하려면?