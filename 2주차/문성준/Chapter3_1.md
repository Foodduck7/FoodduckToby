# Chapter 3, 템플릿

## 중복 코드와 템플릿 패턴
- 중복 코드가 3번 이상 반복된다면, 해당 코드를 개선할 시점이다.
- 템플릿 패턴은 일정한 패턴을 가진 부분을 독립적으로 분리하여 자유롭게 변경할 수 있도록 하는 구조이다.

## 예외처리 기능을 갖춘 DAO

### JDBC 환경에서의 예외 처리
- DB 커넥션은 제한된 리소스이므로, 반드시 적절한 시점에 반환해야 한다.
- 예외 발생 시 리소스를 반환하지 않으면 커넥션 누수(Connection Leak) 문제가 발생할 수 있다.
  (출처: https://velog.io/@dev_tmb/DB-%EC%BB%A4%EB%84%A5%EC%85%98-%ED%92%80-%EB%88%84%EC%88%98-%EB%AC%B8%EC%A0%9C)
- 커넥션 누수가 발생하면 커넥션 풀이 한계에 도달하여 새로운 요청이 차단될 가능성이 있다.
- DB 커넥션 풀을 초과할 경우, 성능 저하 또는 서버 다운과 같은 심각한 문제가 발생할 수 있다.

### 장시간 운영되는 다중 사용자 시스템에서의 문제점

- 커넥션 누수는 메모리 사용 증가 및 성능 저하를 유발한다.

- 스레드가 대기 상태에 빠지면서 서버 응답 지연이 발생할 수 있다.

###  JPA에서 커넥션 누수가 발생하는 원인

- 대량의 데이터 조회로 인한 커넥션 유지

- N + 1 문제로 인해 예상보다 많은 쿼리가 실행됨

- HikariCP (MySQL) 등의 커넥션 풀 설정이 적절하지 않을 경우 발생 가능

## 해결 방안
- jDBC 코드에서 리소스 반환을 위해 try/catch/finally 블록을 사용해야 한다.
-> 이부분이 중요한 것 같음. 누차 강조하고, 구글링에서도 자주 언급함.
- **Spring의 @Transactional**을 활용하면 자동으로 트랜잭션을 관리할 수 있다.
- 커넥션 풀 설정 최적화를 통해 커넥션 누수를 방지할 수 있다.

## JDBC의 try/catch/finally 코드 문제점
- 반복적인 예외 처리 코드가 여러 메소드에서 중복 발생할 수 있다.
- 개발자가 close()를 누락하면 커넥션 누수 문제가 발생할 가능성이 높다.
- 로직 수정 시 모든 부분을 고려하며 변경해야 하는 유지보수 비용 증가

# 디자인 패턴을 활용한 해결책

1. 메소드 추출
공통적인 예외 처리 및 리소스 반환 로직을 별도의 메소드로 분리

2. 템플릿 메소드 패턴 적용
상속을 이용하여 변하지 않는 로직(템플릿)과 변경 가능한 로직(서브클래스)을 분리
- 단점: 확장성이 제한적이며, 설계 시점에서 구조가 고정됨

3. 전략 패턴 적용
클래스 간 의존성을 줄이고 확장성을 높이는 방식 <br>
인터페이스를 활용하여 구체적인 구현을 런타임에 동적으로 변경 가능<br>
→ 단점: 컨텍스트(전략을 호출하는 객체)가 특정 구현체를 알아야 함

4.  DI(Dependency Injection) 적용

클라이언트와 컨텍스트를 분리하여 유연한 의존성 주입을 가능하게 함<br>
Spring의 IoC 컨테이너를 활용하면 객체 생성 및 의존성 관리를 자동화할 수 있음

### 마이크로 DI(수동 DI)

IoC 컨테이너 없이 코드 내에서 직접 DI를 적용하는 방식<br>
전략 패턴의 구조를 따르면서도 유연성을 확보할 수 있음

## ️ 내부 클래스와 익명 클래스

### 로컬 클래스

클래스 내부에 정의되는 중첩 클래스<br>
내부 클래스는 외부 클래스의 정보를 직접 참조 가능

### 중첩 클래스의 종류

스태틱 중첩 클래스: 독립적으로 생성 가능<br>
멤버 내부 클래스: 외부 클래스의 인스턴스 변수에 접근 가능<br>
로컬 클래스: 메소드 내부에서 정의되는 클래스<br>
익명 클래스: 일회성으로 사용되며, 선언과 동시에 객체 생성<br>

### 익명 내부 클래스
인터페이스 구현과 객체 생성을 동시에 수행<br>
주로 콜백 객체를 전달할 때 사용<br>
단점: 가독성이 떨어지고, 재사용이 어렵다<br>
```
SomeInterface obj = new SomeInterface() {
@Override
public void someMethod() {
System.out.println("익명 클래스 내부 로직 실행");
}
};
```


## 스프링 빈과 DI

인터페이스를 사용하지 않는 DI는 마지막으로 고려해야 하는 옵션이다.<br>
온전한 DI 구조를 유지하려면 인터페이스 기반으로 구현하는 것이 바람직하다.<br>
단, Spring의 DI는 객체의 생성과 관계 설정을 외부로 위임하는 IoC 개념을 포괄하기 때문에 인터페이스 없이도 DI를 적용할 수 있다.

## 템플릿과 콜백 패턴

### 템플릿 & 콜백이란?

템플릿: 고정된 틀 안에서 변할 수 있는 부분을 정의하는 방식<br>
콜백: 다른 객체의 메소드 실행을 목적으로 전달되는 오브젝트

## 템플릿 메소드 패턴과의 차이점

템플릿 메소드 패턴은 상속을 이용해 기능을 확장<br>
템플릿 & 콜백 패턴은 인터페이스 기반으로 동작하여 확장성이 뛰어남

## 클라이언트, 템플릿, 콜백의 관계 
(순서 암기하는게 좋아보임)
1️⃣ 클라이언트 → 콜백 객체를 생성하고 템플릿을 호출하면서 콜백을 전달
2️⃣ 콜백 → 클라이언트가 생성한 객체로, 템플릿이 호출하는 메소드를 구현
3️⃣ 템플릿 → 콜백의 메소드를 실행하여 필요한 작업을 수행

### 템플릿 콜백 패턴 적용 기준
try/catch/finally 코드가 반복적으로 사용되는 경우 적용하는 것이 적절함<br>
익명 내부 클래스를 활용하면 코드의 간결성과 유연성을 증가시킬 수 있음<br>
단점: 코드 가독성이 떨어질 수 있음 (적절한 추상화가 필요함)

# 정리

중복 코드가 3번 이상 반복되면 개선 필요

예외 처리 및 리소스 반환이 중요하며, 이를 해결하기 위해 템플릿 패턴을 활용

전략 패턴, DI, 익명 클래스, 콜백 패턴 등 다양한 기법을 활용해 유지보수성을 높일 수 있음

스프링에서 DI를 활용하면 객체 생명주기 관리와 의존성 관리를 자동화할 수 있음

템플릿 & 콜백 패턴을 활용하면 유연한 구조로 코드 중복을 최소화할 수 있음