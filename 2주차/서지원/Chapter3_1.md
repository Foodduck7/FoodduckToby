# Chapter3 템플릿

<br>

# 🎈 <ins>**중복이 3번 이상 반복된다면 코드를 개선할 시점**</ins>이라고 생각해야한다. 

<br>

## 템플릿
**일정한 패턴으로 유지되는 특성을 가진 부분**을 **자유롭게 변경되는 성질을 가진 부분**으로부터 <span style="color:orange;">**독립시켜 효과적으로 활용**</span>할 수 있도록 하는 방법을 의미한다. 


<br>

### 예외처리 기능을 갖춘 DAO

`DB 커넥션`이라는 제한적인 **리소스를 공유해 사용하는 서버**에서의 JDBC 코드에서는 예외가 발생했을 경우 <span style="color:#F05750;">**리소스를 반드시 반환**</span>해야한다. 

<br>

✅ **리소스 반환을 하지 않으면 생기는 문제**

<span style="color:#F05750;">**예외 발생 시 리소스를 반환하지 않으면**</span> **커넥션이 계속 유지되어 커넥션 풀의 한계를 초과**할 수 있다. 

그럴 경우 `새로운 요청`이 **커넥션을 얻지 못해 서버 다운 또는 성능 저하 발생**가 발생된다. 


> 💡  `커넥션`은 소켓, 메모리 **등 무거운 리소스를 사용하므로 반환하지 않으면 불필요한 점유로 성능 저하 유발한다.**
> 
> 🚨 **장시간 운영되는 다중 사용자를 위한 서버**에 적용하기에 치명적이다. 🚨


<br>

### 💭  JPA에서 커넥션 누수가 발생되는 원인에는 무엇이 있을까? 

> **대량의 데이터 조회, N + 1문제로 불필요한 쿼리 다수 발생**
> 
> [99%가 모른다는 DB Connection 누수 문제](https://helloworld.kurly.com/blog/connection-leak/?utm_source=chatgpt.com)
> 
> [ORM(JPA) 사용 시 예상치 못한 쿼리로 인한 HikariCP(Mysql) 이슈](https://saramin.github.io/2023-04-27-order-error/?utm_source=chatgpt.com)
> 


<br>


✅ 해결방안 

`JDBC 코드`에서 해당 상황을 해결하기 위해 가져온 리소스를 반환하는 <span style="color:orange;">**try/catch/finally문 사용을 권장**</span>한다. 

<br>

### JDBC의 try/catch/finally 코드의 문제점

복잡한 try/catch/finally문을 모든 메소드마다 반복하게 되는 경우 발생 

**💭 만약 개발자가 실수로 close()를 넣지 않는다면?**

- 언젠간 DB 커넥션 누수 문제 발생 
- 로직 수정 시 모든 부분을 고려하며 수정해야한다. 

<br>

### 분리와 재사용을 위한 디자인 패턴 적용

**1.  메소드 추출** 

**2. 템플릿 메소드 패턴의 적용**

- ︎ 템플릿 메소드의 경우 `상속을 통해 새로운 클래스`를 만들어야 한다는 단점이 존재 
- `확장 구조`가 이미 <span style="color:orange;">**클래스를 설계하는 시점에서 고정**</span>되어 버린다. 

**3. 전략 패턴의 사용**

➡︎ **오브젝트를 아예 둘로 분리**하고 `클래스 레벨`에서는 **인터페이스를 통해서만 의존**하도록 만드는 전략 패턴 사용

![Image](https://github.com/user-attachments/assets/bca93c09-ff0b-4fad-9b34-b4b621d30cda)

컨텍스트가 인터페이스와 특정 구현체를 알고 있어야 하기 때문에 전략 패턴 및 OCP에 맞지 않는다. 

**4. DI 적용을 위한 클라이언/컨텍스트 분리** 

![Image](https://github.com/user-attachments/assets/b942f3d4-d841-4727-8046-64a094cd82f3)

> 💡 **마이크로 DI (수동 DI)**
> 
> 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만드는 것 
> 
> ➡︎ `전략 패턴 구조`에 따라 **클라이언트가 오브젝트 팩토리의 책임을 함께 지고 있을 수 있다.** 
> 
> 그런 경우 Ioc 컨테이너의 도움 없이 코드 내에서 적용한 경우를 <span style="color:orange;">**마이크로 DI**</span> 혹은 <span style="color:orange;">**수동 DI**</span>라고 부를 수 있다. 


<br>

### 로컬 클래스 
**클래스 안에 내부 클래스로 정의하는 것** 

> 💡 **중첩 클래스의 종류** 
>
> **독립적으로 오브젝트로 만들어질 수 있는** `스태틱 클래스`와 정의된 클래스의 **오브젝트 안에서 만들어질 수 있는** `내부 클래스`로 구분된다. 
> 
> **[내부 클래스]**
> 
> 범위에 따라 3가지로 구분된다. 
> 
> - `오브젝트 레벨`의 <ins>**맴버 내부 클래스**</ins> 
> - `메소드 레벨`의 <ins>**로컬 클래스**</ins>
> - 이름을 갖지 않는 <ins>**익명클래스**</ins> (선언 위치에 따라 범위가 다르다)

**[장점]**


-  클래스가 내부 클래스이기 때문에 **자신이 선언된 곳의 정보에 접근**할 수 있다. 
- 메소드마다 추가해야 했던 **클래스 파일을 줄일 수 있다.** 

다만, 내부 클래스에서 <span style="color:#F05750;">**외부 변수를 사용할 때는 반드시 final로 선언**</span>해야한다. 


<br>

### 익명 내부 클래스 

선언과 오브젝트 생성이 결합된 형태 

클래스를 재사용할 필요가 없고 구현한 인터페이스 타입으로만 사용할 경우 유용 ➡︎...?

`new 인터페이스 이름() {클래스 본문}`


<br>

### 스프링 빈으로 DI 

**인터페이스를 사용하지 않고 DI 적용** <span style="color:orange;">**가장 마지막으로 고려되어야 하는 사항**</span> 

➡︎ 인터페이스를 사용하지 않는 것은 온전한 DI라고 볼 수 없지만, 스프링의 DI는 넓게 보면 **객체의 생성과 관계 설정에 대한 제어권한을 오브젝트에서 제거**하고 **외부로 위임했다는 Ioc 개념**을 포괄한다. 


<br>

## 템플릿과 콜백

전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식을 의미한다. 

`템플릿:`전략 패턴의 컨텍스트 

`콜백:` 익명 내부 클래스로 만들어지는 오브젝트

> 💡 **템플릿**
> 
> **고정된 틀 안에서 바꿀 수 있는 부분을 넣어서 사용하는 경우** 
> 
> 💡 **템플릿 메소드 패턴** 
> 
> 고정된 틀을 슈퍼클래스에 두고 바뀌는 부분을 서브 클래스에 두는 패턴
> 
> 💡 **콜백 (펑셔널 오브젝트)**
> 
> 실행되는 것을 목적으로 **다른 오브젝트의 메소드**에 <span style="color:orange;">**전달되는 오브젝트**</span>를 의미한다. 


<br>

### 템플릿과 콜백 특징 
보통 특정 기능을 위해 한번 호출되는 경우가 일반적이기 때문에 단일 **메소드 인터페이스** 사용한다. 

적용할 때는 콜백의 인터페이스를 정의해야하기 때문에 **템플릿과 콜백의 경계를 정하고** `템플릿 ➡ ︎콜백` `콜백 ➡︎ 템플릿` 에게 <span style="color:#F05750;">**전달하는 내용이 무엇인지 파악하는 것이 중요**</span>하다. 

<br>

#### 🚀 클라이언트와 템플릿, 콜백의 작업 흐름 

**[클라이언트]**

콜백 오브젝트를 만들고 콜백에게 참조할 정보를 제공하며, <span style="color:orange;">**템플릿의 메소드를 호출 및 콜백 전달을 담당**</span>한다. **(1)**

**[콜백]**

- 클라이언트를 통해 만들어진 콜백은 메소드 호출 시 파라미터로 전달된다. **(2)**
- `클라이언트 메소드에 있는 정보`와 `템플릿이 제공한 참조 정보`를 이용해 **작업 수행 후 해당 결과를 템플릿에 돌려준다.** **(4)**

**[템플릿]**

내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. **(3)**

<br>

#### 🚀 특징
- 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받는다. 

- 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조 

- 클라이언트와 콜백이 강하게 결합


#### ⚠️ DAO 메소드에서 `매번 익명 내부 클래스를 사용`하여 상대적으로 코드 작성 및 읽기가 불편하다. 


<br>

> 💭 **템플릿 콜백 패턴은 언제 적용해야할까?** 
> 
> `try/catch/finally 블록`을 사용하는 코드가 3번 이상 사용된다면 적용하기 적당하다. 
