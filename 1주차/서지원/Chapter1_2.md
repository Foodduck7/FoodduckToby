# Chapter1-2 싱글톤 레지스트리와 오브젝트 스코프 & DI

## 오브젝트의 동일성과 동등성
⚠️ Java에서는 2개의 <span style="color:#F05750;">**오브젝트가 같다는 말을 주의**</span>해서 사용해야 한다.

- 2개의 정보가 완전히 같은 것 ➡︎ **동일성(Identity)** : `== 연산자 사용`
- 동일한 정보를 담고 있는 것 ➡ **︎동등성(equality)** : `equals() 메서드 사용`

### 직접 사용 VS @Configuration
**[직접 사용]**
```java
Dao factory = new Dao();

UserDao dao1 = factory.userDto();
UserDao dao2 = factory.userDto();

System.out.println(dao1); //ex> x001
System.out.println(dao2); //ex> x002
```
<br>

**[@Configuration로 Dao 등록]**

애플리케이션 컨텍스트에 Dao 정보 등록 후 가져온 오브젝트는 몇번을 호출해도 모두 동일한 주소?를 가진다. 


## 애플리케이션 컨텍스트 (싱글톤 레지스트리)
애플리케이션 컨텍스트는 **싱글톤을 저장하고 관리하는** `싱글톤 레지스트리`이기도 하다.
> 💡 스프링은 기본적으로 내부에서 생성하는 **빈 오브젝트를 모두 싱글톤**으로 만든다. 

<br>

### **💭 그렇다면, 스프링은 왜 싱글톤으로 빈을 만드는 것일까?**
**이유: <ins>엔터프라이즈</ins> 기술을 사용하는 <span style="color:orange;">서버 환경</span>**

<span style="color:orange;">➡</span> **︎서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경**

**클라이언트에서 요청이 올 때마다** 각 로직을 담당하는 <ins>**오브젝트를 새로 만들어서 사용한다고 했을 때**</ins>, 아무리 <span style="color:#F05750;">**성능이 좋아도 부하가 걸리게 된다면 서버가 감당하기 힘들어진다.** </span> 

- 엔터프라이즈 분야의 가장 기본이 되는 서비스 오브젝트인 `서블릿`은 대부분 **멀티스레드 환경에서 싱글톤으로 동작**한다.
- 사용자의 요청을 담당하는 여러 스레드에서 <ins>하나의 오브젝트를 공유해 동시에 사용</ins>한다. 

<br>

### 싱글톤 패턴의 한계
**java에서 싱글톤을 구현하는 방법**
1. 생성자를 private로 만든다. 
2. 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드 정의
3. 최초로 호출되는 시점에 오브젝트가 한번 생성된 후 스태틱 필드에 저장 
4. 스태틱 필드에 저장해둔 오브젝트를 메서드를 통해 넘겨준다. 

**문제점**

- private 생성자를 가진 클래스는 <ins>**다른 생성자가 없다면, 상속이 불가능**</ins>하다. 
- 싱글톤은 <ins>**테스트하기 어렵다.**</ins> 
- java 언어를 이용한 싱글톤 패턴 기법은 <ins>**서버 환경에서 싱글톤이 꼭 보장된다고 볼 수 없다.**</ins>  

  ➡ 여러개의 `JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생긴다.` 
- 싱글톤을 사용하는 클라이언트가 정해져 있지 않기 때문에 <ins>**전역상태(global state)로 사용되기 쉽다.**</ins> ︎

> ❗서버 환경에서 서비스 싱글톤의 사용이 권장되기는 하지만, 까다롭고 여러 문제가 있기 때문에 피해야하는 `안티 패턴`으로 불리기도 한다. 
> 
> 따라서, 이러한 싱글톤 패턴은 <span style="color:orange;">**당일 오브젝트만 존재하고 이를 애플리케이션의 여러곳에서 공유하는 경우에 주로 사용**</span>한다. 
>

<br>

이처럼 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 존재한다. 

따라서, 스프링은 직접 **싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공**한다. ➡ `︎싱글톤 레지스트리`

<br>

## 싱글톤과 오브젝트의 상태
**멀티스레드 환경에서 여러 스레드가 동시에 접근해서 사용할 수 있다면**, 우리는 상태 관리에 주의를 기울여야한다. **[RaceCondition]**

즉, <span style="color:orange;">**Stateless**</span>해야한다. 

- 싱글톤의 경우 저장할 공간이 하나뿐이므로 서로의 값을 덮어쓰거나 자신이 설정하지 않은 값을 읽어오는 문제가 발생할 수 있다. 

> 💡 물론 `읽기 전용의 값`이라면 **초기화 시점에서 인스턴스 변수에 저장해두고 공유**하는 것은 문제가 되지 않는다. 

<br>

### **💭 상태가 없는 방식으로 각 요청에 대한 정보나, DB의 생성 정보는 어떻게 다뤄야 할까?**

**파라미터와 로컬 변수, 리턴 값 등을 이용한다.**

➡ 메소드 파라미터나 메소드 안에서 생성되는 `로컬 변수`는 <span style="color:orange;">**매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에**</span> 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다. 


<br>

### 스프링 빈의 스코프
빈이 생성되고 존재하고 적용되는 범위를 의미한다. 

- 싱글톤: 기본  스코프
- 프로토 타입 스코프: 컨테이너가 빈을 요청할 때마다 새로운 오브젝트를 만들어 준다. 
- 요청 스코프: 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성되는 스코프
- 세션 스코프: 웹과 유사 


<br>

## 의존 관계 주입 (DI: 의존 관계 주입 담당 컨테이너)
Ioc 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 

> 💡 **의존 관계 주입이란?**
>
>DI는 **오브젝트 레퍼런스를 외부로부터 제공**받고 이를 통해 **다른 오브젝트와 의존관계가 만들어지는 것** 
> 
> DI는 자신이 사용할 `오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고` **자신은 수동적으로 주입받은 오브젝트를 사용한다는 점**에서 IOC의 개면에 잘 들어맞는다.
> 
> DI는 <span style="color:orange;">**인터페이스 타입의 파라미터**</span>를 통해 이루어져야한다. 


### 의존 관계
![Image](https://github.com/user-attachments/assets/94b84399-dee6-4834-84d2-d730ff19bf57)

2개의 클래스 or 모듈에 의존 관계가 있다고 말할 때는 <span style="color:orange;">**항상 방향성을 부여**</span>해 주어야한다. 즉, A가 B에게 의존하는 관계

➡︎ B가 변하면 그것이 A에 영향을 미치는 것 **즉, B의 기능이 추가, 변경되면 그 영향이 A에게 전달된다.** 


### 의존 오브젝트 
코드에서는 클래스와 인터페이스를 통해 드러나는 의존관계말고 `런타임 시`에 <ins>**의존관계를 맺는 대상을 의존 오브젝트**</ins>라고 한다. 


### 의존 관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체(오브젝트)를 런타임 시에 연결해주는 작업을 말한다.

```java
public class Dao {
    private final Service service;

    public Dao(Service service) {
        this.service = service;
    }
}
```

> 💡 **런타임 관계를 맺어주는 제 3의 존재?** 
> 
> 애플리케이션 컨텍스트, 빈 팩토리, IOC 컨테이너 등 
> 

<br>

### 의존 관계 검색과 주입 
- 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 
- 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
- 애플리케이션 컨테스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 
- <span style="color:orange;">**테스트 코드에서 의존관계 검색 방식 사용**</span>


<br>

### 의존 관계 주입의 응용
DI기술의 장점
- 다른 오브젝트가 바뀌어도 자신은 영향을 받지 않는다. 
- 다양한 확장 방법이 가능하다.

<br>

### 기능 구현의 교환 및 부가기능 추가(추후 더 찾아보면 좋을 것 같다.)
<span style="color:#F05750;">**DB는 평상시에도 항상 부하를 많이 받고 있어 개발 중에는 절대 사용하지 말아야한다.**</span> 

이때, 의존관계를 이용한다면 **DI 설정 정보에 해당하는 부분만 다르게 구현**하고 다른 코드는 수정하지 않아도 개발, 운영 시에 각각 다른 런타임 오브젝트에 의존관계를 가지게 할 수 있다. 


<br>

### 메서드를 이용한 의존관계 주입
- **수정자 메소드를 이용한 주입**

  ➡ 외부에서 내부의 값을 변경하려는 용도 **[setter]**

<br>

- **일반 메소드를 이용한 주입**