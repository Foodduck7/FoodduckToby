# Chapter2-1 테스트  



## 🛏️ 테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것

## 😣 개발자가 테스트를 직접 만들 때 자주하는 실수는?

> ➡︎  성공하는 테스트만 골라서 만드는 것   
➡︎  문제가 될 만한 상황이나, 입력 값 등은 교묘하게 피해서 코드를 만든다.

<br>

## 테스트의 유용성
테스트라는 것은 내가 **예상하고 의도했던 대로 코드가 정확히 동작하는지 확인**하고, **확신**할 수 있도록 해주는 작업이다. 

`테스트 결과가 원하는 대로 나오지 않는 경우` <span style="color:orange;">**코드나 설계에 결함이 있음을 확인**</span>할 수 있고 결함을 제거해가는 <span style="color:#F05750;">**디버깅 과정**</span>을 거치며 **최종적으로 테스트가 성공했을 때 모든 결함이 제거되었다는 확신**을 얻을 수 있다.
<br>

자바를 통해 간단한 테스트 코드 작성하기 ➡︎ `main 메서드 사용: 테스트할 대상을 직접 호출해서 사용한다. `

<br>

## 웹을 통한 테스트 방법의 문제점
서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 우선 간단하게 만든 후 웹을 통해 값을 입력한 뒤 버튼을 눌러 확인한다. 

> ⚠️ 이처럼 웹 화면을 통해 <ins>**값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법**</ins>은 가장 흔히 쓰이는 방법이지만 <span style="color:#F05750;">**모든 레이어 기능을 다 만들고나서 테스트 가능**</span>하다는 단점이 있다. 
>
> ➡︎ 테스트를 하는 중 에러가 나거나 실패했을 때 **어디에서 문제가 발생했는지 찾아내야하는 수고가 필요**
> 
> 

<br>

### 💭 그렇다면 테스트를 어떻게 만들어야 이러한 문제를 피하고 효율적으로 테스트를 활용할 수 있을까?

### 🔵 작은 단위의 테스트

너무 많은 것을 몰아서 테스트하면 원인을 찾기 힘들기 때문에 작은 단위로 쪼개서 작성한다.  ➡︎ **단위 테스트 (Unit Test)**

> 💡 **크기와 범위가 어느 정도인지 정해져 있지 않고** 크게는 사용자 관리을 모두 통들어 하나의 단위로 볼 수도 있고 작게 보면 메소드 하나만 가지고 하나의 단위로 볼 수도 있다. 
> 
> **사용할 DB의 상태를 테스트가 관장**하고 있다면 `단위 테스트`라고 해도 되지만, **DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면** `단위 테스트로서 가치가 없어진다.`


<br>

**회원가입 ➡︎ 로그인 ➡︎ 데이터 등록 등의 과정**을 하나로 묶을 경우 안되는 경우가 생길 수 있기 때문에 테스트해야하는 경우가 생긴다.

<br>

### 🔵 자동수행 테스트 코드

**테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요**하다. 

자동으로 수행되는 테스트의 장점은 **자주 반복할 수 있는 점이다.** 

<br>

### 🔵 점진적인 개발을 위한 테스트
테스트를 이용하면 새로운 기능도 확인할 수 있고 기존에 만들어뒀던 기능들이 <span style="color:orange;">**수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지 확인**</span>할 수 있다. 


<br>

## main()을 통한 테스트 코드의 문제점

- **수동 확인 작업의 번거로움**
  
  ➡ ︎테스트 결과를 확인하는 일은 개발자의 책임이므로 완전한 자동 테스트 방법이라고 할 수 없다.  

<br>

- **실행 작업의 번거로움** 

<br>

- **애플리케이션 규모가 커지고 테스트 개수가 많아지면 점점 부담이 된다.** 

<br>


## JUnit

자바 테스팅 프레임워크라고 불리는 JUnit은 단위 테스트를 만들 때 유용하게 쓸 수 있다. 


➡︎ `프레임워크`에서 동작하는 코드는 <ins>**main() 메소드도 필요없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.** </ins>

> JUnit도 자바 코드로 만들어진 프로그램이기 때문에 어디선가 한번은 시작시켜주어야 한다. **[JUnitCore]**  (JPA에서는? ➡︎ 찾아보기)
> 

<br>

### 테스트 메소드로 전환하기 

테스트가 main()에 있다는 의미는 제어권을 직접 가지다는 의미이기 때문에 일반 메서드로 테스트 코드를 옮긴다. 


**[조건]**

- 메소드는 <span style="color:orange;">**public**</span>으로 선언되어야 한다. (JPA에서 public 생략)
- <span style="color:#FFD700;">**@Test** </span>어노테이션을 붙여준다. 

```java
@Test
void 테스트_코드() {
  ...
}
```

<br>

### 검증 코드 전환하기 

기존 if를 통한 검증 로직을 JUnit이 제공해주는 `assertThat이라는 스태틱 메서드`로 변경한다. 

```java
@Test
void 테스트_코드() {
  ...
  assertThat(user2.getName(), is(user1.getName)); //검증 실패 시 AssertionError 발생
}
```
> `매처(Matcher): ` assertThat 첫번째 파라미터의 값 뒤에 나오는 것 
> 
> **ex> is() -> equals()로 비교해 주는 기능**


<br>


### IDE

IDE는 JUnit 테스트를 손쉽게 실행할 수 있는 JUnit 테스트 지원 기능을 내장하고 있다. 

> 💡 책에서는 이클립스를 기준으로 설명해서 추후 인텔리제이에 대해서도 찾아보면 좋을 것 같다. 

<br>

**프로젝트 빌드**

ANT나 메이븐(Maven)을 사용하고 있으면 해당 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 실행


<br>


### 테스트 결과의 일관성

`단위 테스트`는 항상 <span style="color:orange;">**일관성 있는 결과가 보장**</span>되어야 한다.   

- deleteAll : 테스트가 끝나고 테스트가 등록한 사용자 정보 삭제
- getCount() : 레코드 개수를 돌려준다. 

<br>


> 💡 **JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다.**
> 
>  즉, 모든 테스트는 실행 순서에 상관없이 **독립적으로 항상 동일한 결과를 낼 수 있도록** 해야한다. 


<br>


### 테스트 예외 처리 

```java
@Test(expected=EmptyResultDataAccessException.class) //테스트 중에 발생할 것으로 기대하는 예외 클래스를 지정
```

**expected가 지정한 예외가 던져지면 테스트가 성공한다.** 



<br>


### 테스트가 이끄는 개발이란? 

테스트에는 만들고 싶은 기능에 대한 <span style="color:orange;">**조건, 행위, 결과**</span>를 표현한다. 

| 단계 | 어떤 조건을 가지고 | 내용 |
|------|-------------------|------|
| 조건 | 어떤 조건을 가지고 | 가격을 상자 정보가 존재하지 않는 경우에 |
| 행위 | 무엇을 할 때 | 존재하지 않는 id로 get()을 실행하면 |
| 결과 | 어떤 결과가 나온다 | 특별한 예외가 던져진다 |


이처럼 **테스트 코드를 먼저 설계**하고 개발하는 것을 `테스트 주도 개발 (TDD)`라고 한다. 

➡︎ 처음에는 익숙하지 않을 수 있지만 TDD 방법을 통해 개발을 한다면 후에 테스트와 코드 작성 시간을 줄일 수도 있다. 

<br>


### 테스트 코드 개선

`테스트 코드`도 언제든지 내부 구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 **변경이 용이한 코드로 만들 필요가 있다.** 

#### <span style="color:#FFD700;">**@Before** </span>
**테스트 메소드를 실행하기 전에 먼저 실행 시켜주는 기능**

```java

private Dao dao;
@Before //먼저 실행되어야 하는 메소드를 정의한다. 
public void setUp() {
    Dao dao = new Dao("이름", "비밀번호");
    this.dao = dao;
}
```

> 💡 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위해 매번 새로운 오브젝트를 만든다. 


<br>

#### 픽스처
테스트를 수행하는데 필요한 정보나 오브젝트를 의미한다. 

➡︎  여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해 두면 편하다. 
