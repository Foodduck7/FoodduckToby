53~101page / 25년 3월 3일 (월) 

<hr>

# 1. DAO와 IoC(초난감 dao)
## 1.1 dao
- db에 접근하는 로직을 분리한 객체
- 유지보수성과 재사용성을 높이기 위한 설계

## 1.2 초난감 dao의 문제점
- 직접적인 db연결 정보 및 쿼리를 포함한다.
- 코드의 중복이 발생한다.
- 변경이 발생하면 여러 부분을 수정 해야하는 문제점이 있다 -> 이는 결합도를 높이는 것이다.

## 1.3 관계설정 책임의 분리
- 객체 간 관게 설정은 외부에서 주입해야 한다.
- 클래스 내부에서 객체를 직접 생성하지 않도록 설계해야한다.
- 어떻게?
  - "메서드 파라미터" 를 통해 객체 전달
  - "생성자 파라미터" 를 통해 객체 전달

<hr>

# 2. SOLID 원칙과 디자인 패턴
## 2.1 객체지향의 5대 원칙(SOLID)
### 1. SRP - 단일 책임 원칙
- 하나의 클래스는 하나의 책임만 가진다
### 2. OCP - 개방 폐쇄 원칙
- 클래스나 모듈은 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
### 3. LSP - 리스코프 치환 원칙
- 하위 클래스는 상위 클래스를 대체할 수 있어야 한다.
### 4. ISP - 인터페이스 분리 원칙 
- 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.
### 5. DIP - 의존성 역전 원칙
- 상위 모듈이 하위 모듈에 의존하지 않도록 설계해야 한다.
- 구체적인 구현보다는 추상화에 의존해야 한다.
## 2.2 높은 응집도와 낮은 결합도
### 응집도란 ?
- 클래스가 하나의 관심사 또는 책임에만 집중되어있는 정도를 말한다.
  - 응집도가 높으면 변경 시 관련 부분만 수정하면 된다.
### 결합도 ?
- 한 객체의 변경이 다른 객체에 영향을 미치는 정도를 맗나다.
  - 결합도가 낮아야 유지보수성이 증가한다. (살짝, 상속을 지양하자는 것이 객체지향에 가까운 것이다 라는 생각이 든다)
## 2.3 전략 패턴
- 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 분리하는 패턴이다.
- 알고리즘을 독립적인 책임으로 분리하여 유지보수성을 높인다.
- 필요에 따라 알고리즘을 바꿔 사용할 수 있다.
## 2.4 팩토리 패턴
- 객체의 생성 방법을 결정하고, 객체를 생성해 반환하는 역할을 한다.
- 객체 생성 로직을 감춰 유연한 설계를 가능하게 한다.

<hr>

# 3.IoC - 제어의 역전
## 3.1 제어의 역전이란?
- 프로그램의 흘므을 직접 제어하는 것이 아니라, 제어권을 프레임워크나 컨테이너가 담당하는 개념이라고 보면 된다.
- 개발자는 필요할 때 특정 기능을 호출하는 것이 아니라, 프레임워크가 호출하도록 설계해야 한다.
## 3.2 라이브러리 vs 프레임워크
- 라이브러리 : 어플리케이션 코드가 직접 라이브러리를 호출하여 사용한다.
- 프레임워크 : 어플리케이션 코드가 프레임웤크에 의해 사용된다.(IoC적용)
## 3.3 IoC의 필요성
- 객체의 생성, 관계 설정, 생명주기 관리 등을 컨테이너가 담당한다.
- 이를 통해 개발자는 비즈니스 로직에 집중할 수 있게 되는 것이다.

<hr>

# 스프링 컨테이너와 빈
## 4.1 Bean ?
- 스프링이 직접 생성하고 관리하는 객체이다.
- app 컴포넌트로, 관계 설정 및 생명주기 관리르 스프링 컨테이너가 담당하는 것으로 생각하면 된다.
## 4.2 Bean Factory ?
- 스프링의 Ioc 컨테이너 중 하나이다.
- 빈의 생성과 관계 설정 등을 담당한다.
- 근데, 요즘은 **ApplicationContext**를 더 많이 사용하는 것 같다.
## 4.3 application Context ?
- 빈을 생성하고, 관계를 설정하는 역할을 총괄하는 컨테이너다.
- XML 또는 Java Config 기반 설정을 지원한다.
## 4.4 설정 정보와 메타데이터(Configuration Metadat)
- 컨테이너가 관리하는 객체를 생성하고 구성하는 데 사용되는 정보이다.
- app의 청사진(blueprint) 역할을 수행한다고 생각하면 된다.
  * blueprint : 아키텍처 또는 공학 설계를 문서화한 기술 도면을 인화로 복사하거나 복사한 도면. (쉽게 설명해, 어떠한 자세한 계획을 말한다)

## 4.5 @Configuration && @Bean
- Configuration : 해당 클래스가 스프링 설정 클래스로 인식되도록 지정한다
- Bean : 빈을 생성하는 메서드에 적용하여 스프링 컨테이너에서 관리하도록 설정한다.



# 정리
- DAO를 설계할 때는 객체 간 관계 설정 책임을 분리해야 한다.
- SOLID 원칙을 따르고 디자인 패턴을 적용하면 유지보수성이 높은 코드 작성이 가능하다.
- 제어의 역전 (IoC)은 프레임워크를 활용하여 객체 생성과 관계를 관리하는 핵심 개념이다.
- 스프링 컨테이너는 빈을 생성하고 관계 설정 및 생명주기를 관리하여 IoC를 실현한다.
## 주요 개념 정리
<img width="697" alt="image" src="https://github.com/user-attachments/assets/e51a7539-0cf8-4383-90d8-e373ad689ba3" />


# 질문
## 1. 결합도를 낮추는 다양한 방법이 있을까?
- 상속을 지양하는 것 외에도 인터페이스를 적극 활용하거나, DI(Dependency Injection)를 효과적으로 활용하는 방법이 있을까?
- 구체적인 예제 코드와 함께, 스프링에서 결합도를 낮추는 실제적인 전략은 무엇이 있을까 ?
## 2. IoC의 구현 방식에는 어떤 것들이 있을까?
- IoC는 **DI(Dependency Injection)**의 개념과 밀접하게 연결되어 있는데, IoC를 구현하는 방식으로 생성자 주입, 필드 주입, 세터 주입이 있다.
- 각각의 장단점과 실무에서 가장 선호되는 방법이 무엇이 있을까 ?
## 3. 스프링 컨테이너의 종류에는 어떤 것들이 있을까?
- ApplicationContext 외에도 다양한 스프링 컨테이너(예: WebApplicationContext, AnnotationConfigApplicationContext)가 있는데, 각각의 역할과 차이를 더 생각하며, 정리해본다면? 
## 4. 스프링의 다양한 디자인 패턴을 좀 더 살펴볼까?
- 현재 팩토리 패턴과 전략 패턴을 언급했는데, 스프링에서 사용하는 프록시 패턴, 데코레이터 패턴, 옵저버 패턴 등의 추가적인 패턴도 포함하면 좋을 것 같은데 어떻게 생각 하시는지 ?
## 5. JPA를 사용하는 경우 DAO 개념이 완전히 사라지는가?
- JPA가 DAO의 역할을 대신한다고 하지만, JPA를 사용하더라도 Repository 계층이 필요한 이유를 명확하게 말한다면 ?
- Spring Data JPA의 내부 동작 방식과, 기존 DAO 패턴과의 차이점을 비교한다면 ?
